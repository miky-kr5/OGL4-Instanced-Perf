/******************************************//*  Simple implementation of an OBJ loader *//*            Duplicate vertex            *//******************************************/#include <stdio.h>#include <vector>#include <string.h>#include <fstream>#include <iostream>#include <cmath>class Vec3{public:	Vec3(){X = 0; Y = 0; Z = 0;}	Vec3(float val){X = val; Y = val; Z = val;}	Vec3(float x, float y, float z){X = x; Y = y; Z = z;}	~Vec3(){}	inline void operator=(Vec3 b)	{		X = b.X;		Y = b.Y;		Z = b.Z;	}	inline Vec3 operator-(Vec3 b)	{			Vec3 newVec;		newVec.X = X - b.X;		newVec.Y = Y - b.Y;		newVec.Z = Z - b.Z;		return newVec;	}	inline Vec3 operator/(float b)	{		Vec3 newVec;		newVec.X = X / b;		newVec.Y = Y / b;		newVec.Z = Z / b; 		return newVec;	}	inline friend std::ostream& operator<<(std::ostream& out, const Vec3& v)	{		out << "X:" << v.X << " Y:" << v.Y << " Z:" << v.Z;	}		float X, Y, Z;};class Vec2{public:	Vec2(){X = 0; Y = 0;}	Vec2(float val){X = val; Y = val;}	Vec2(float x, float y){X = x; Y = y;}	~Vec2(){}	inline friend std::ostream& operator<<(std::ostream& out, const Vec2& v)	{		out << "X:" << v.X << " Y:" << v.Y; }	float X, Y;};class BasicObjLoader{public:	BasicObjLoader(){}	~BasicObjLoader(){}		// Loads and obj file and returns false if some error occurs	// Reads only the first mesh on the file	bool loadObj(const char* fileName)	{		std::ifstream file;		file.open(fileName, std::ios::in);		if(!file.is_open())		{			printf("File not found: %s\n", fileName);			return false;		}		std::string line;		bool loadedName = false, first = false;		Vec3 minCoord, maxCoord;		do		{			std::getline(file, line);			if(!file.eof())			{				if(line[0] == 'o') //Read Object Name				{					if(loadedName) break;					loadedName = true;										strtok((char*)line.c_str(), " ");										Name = strtok(NULL, " ");				}				else if (line[0] == 'v') //Read Vertex				{					readVertex(line, vPositions, vNormals, vTextures, first, minCoord, maxCoord);				}				else if (line[0] == 'f') //Read Triangle				{					readTriangle(line);				}			}		}while(!file.eof());		normalize(minCoord, maxCoord);		return true;	}	inline friend std::ostream& operator<<(std::ostream& out, const BasicObjLoader& o)	{		out << "Mesh Loaded: " << o.Name << " Vertex Count: " << o.vPositions.size() << " Triangles Count: " << o.Triangles.size() / o.dataPerTriangle;	}	float * generateBufferData()	{		int size = Triangles.size() / dataPerTriangle;		float* bufferData = new float[size * 6 * 3];		int dataPerVertex = dataPerTriangle / 3;		int cont = 0;		for(int j = 0; j < Triangles.size(); j += dataPerVertex, cont += 6)		{			bufferData[cont    ] = vPositions[Triangles[j]].X;			bufferData[cont + 1] = vPositions[Triangles[j]].Y;			bufferData[cont + 2] = vPositions[Triangles[j]].Z;			bufferData[cont + 3] = vNormals[Triangles[j + 1]].X;			bufferData[cont + 4] = vNormals[Triangles[j + 1]].Y;			bufferData[cont + 5] = vNormals[Triangles[j + 1]].Z;		}		return bufferData;	}	std::vector<Vec3> vPositions; //Vertex Positions	std::vector<Vec3> vNormals; //Vertex Normals	std::vector<Vec2> vTextures; //Vertex Textures	std::vector<unsigned int> Triangles; //Triangles index	std::string Name; //Name of the object	unsigned short triangleType;	unsigned short dataPerTriangle;private:	void normalize(Vec3 minCoord, Vec3 maxCoord)	{		int size = vPositions.size();		int x = maxCoord.X - minCoord.X;		int y = maxCoord.Y - minCoord.Y;		int z = maxCoord.Z - minCoord.Z;		float dist = sqrt(x*x + y*y + z*z);		Vec3 center((maxCoord.X + minCoord.X) / 2, (maxCoord.Y + minCoord.Y) / 2, (maxCoord.Z + minCoord.Z) / 2);		if(dist > 1)		{			for(int i = 0; i < size; i ++)			{				vPositions[i] = vPositions[i] - center;				vPositions[i] = vPositions[i] / dist;			}		}		else		{			for(int i = 0; i < size; i ++)			{				vPositions[i] = vPositions[i] - center;			}			}	}	void readVertex(std::string line, std::vector<Vec3>& tmpVertexPosition, std::vector<Vec3>& tmpNormals, std::vector<Vec2> &tmpTextCoord, bool& first, Vec3 &minCoord, Vec3 &maxCoord)	{		if (line[1] == 'n')		{			Vec3 newNormal;			std::sscanf(line.c_str(), "vn %f %f %f", &newNormal.X, &newNormal.Y, &newNormal.Z);			tmpNormals.push_back(newNormal);		}		else if (line[1] == 't')		{			Vec2 newTextCoord;			std::sscanf(line.c_str(), "vt %f %f", &newTextCoord.X, &newTextCoord.Y);			tmpTextCoord.push_back(newTextCoord);		}		else if (line[1] != 'p' && line[1] != 'c')		{			Vec3 newVertexPosition;			std::sscanf(line.c_str(), "v %f %f %f", &newVertexPosition.X, &newVertexPosition.Y, &newVertexPosition.Z);			if (first)			{				minCoord.X = newVertexPosition.X; minCoord.Y = newVertexPosition.Y; minCoord.Z = newVertexPosition.Z;				maxCoord.X = newVertexPosition.X; maxCoord.Y = newVertexPosition.Y; maxCoord.Z = newVertexPosition.Z;				first = false;			}			else			{				minCoord.X = fmin(minCoord.X, newVertexPosition.X); minCoord.Y = fmin(minCoord.Y, newVertexPosition.Y); minCoord.Z = fmin(minCoord.Z, newVertexPosition.Z);				maxCoord.X = fmax(maxCoord.X, newVertexPosition.X); maxCoord.Y = fmax(maxCoord.Y, newVertexPosition.Y); maxCoord.Z = fmax(maxCoord.Z, newVertexPosition.Z);			}			tmpVertexPosition.push_back(newVertexPosition);		}	}	bool readTriangle(std::string line)	{		unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];		if(vNormals.size() == 0 && vTextures.size() == 0)		{			int matches = sscanf(line.c_str(), "f %d %d %d", &vertexIndex[0], &vertexIndex[1], &vertexIndex[2]);			if (matches != 3)			{				printf("Corrupted file\n");				return false;			}			triangleType = 0;			dataPerTriangle = 3;			for (int i = 0; i < 3; i++)			{				Triangles.push_back(vertexIndex[i] - 1);			}		}		else if (vNormals.size() == 0 && vTextures.size() != 0)		{			int matches = sscanf(line.c_str(), "f %d/%d %d/%d %d/%d", &vertexIndex[0], &uvIndex[0], &vertexIndex[1], &uvIndex[1], &vertexIndex[2], &uvIndex[2]);			if (matches != 6)			{				printf("Corrupted file\n");				return false;			}			triangleType = 1;			dataPerTriangle = 6;			for (int i = 0; i < 3; i++)			{				Triangles.push_back(vertexIndex[i] - 1);				Triangles.push_back(uvIndex[i] - 1);			}		}		else if (vNormals.size() != 0 && vTextures.size() == 0)		{			int matches = sscanf(line.c_str(), "f %d//%d %d//%d %d//%d", &vertexIndex[0], &normalIndex[0], &vertexIndex[1], &normalIndex[1], &vertexIndex[2], &normalIndex[2]);			if (matches != 6)			{				printf("Corrupted file\n");				return false;			}						triangleType = 2;			dataPerTriangle = 6;			for (int i = 0; i < 3; i++)			{				Triangles.push_back(vertexIndex[i] - 1);				Triangles.push_back(normalIndex[i] - 1);			}		}		else		{			int matches = sscanf(line.c_str(), "f %d/%d/%d %d/%d/%d %d/%d/%d", &vertexIndex[0], &uvIndex[0], &normalIndex[0], &vertexIndex[1], &uvIndex[1], &normalIndex[1], &vertexIndex[2], &uvIndex[2], &normalIndex[2]);			if (matches != 9)			{				printf("Corrupted file\n");				return false;			}						triangleType = 3;			dataPerTriangle = 9;			for (int i = 0; i < 3; i++)			{				Triangles.push_back(vertexIndex[i] - 1);				Triangles.push_back(normalIndex[i] - 1);				Triangles.push_back(uvIndex[i] - 1);			}		}	}};